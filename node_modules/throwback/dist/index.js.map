{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;AAoBA;;GAEG;AACH,SAAS,eAAe,CACtB,UAAmC;IAEnC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;QAC9B,MAAM,IAAI,SAAS,CACjB,2CAA2C,OAAO,UAAU,EAAE,CAC/D,CAAC;KACH;IAED,KAAK,MAAM,EAAE,IAAI,UAAU,EAAE;QAC3B,IAAK,OAAO,EAAU,KAAK,UAAU,EAAE;YACrC,sBAAsB;YACtB,MAAM,IAAI,SAAS,CACjB,qDAAqD,OAAO,EAAE,EAAE,CACjE,CAAC;SACH;KACF;IAED,OAAO,SAAS,aAAa,CAAC,GAAM,EAAE,IAAgB;QACpD,IAAK,OAAO,IAAY,KAAK,UAAU,EAAE;YACvC,sBAAsB;YACtB,MAAM,IAAI,SAAS,CACjB,2DAA2D,OAAO,IAAI,EAAE,CACzE,CAAC;SACH;QAED,IAAI,KAAK,GAAG,CAAC,CAAC;QAEd,SAAS,QAAQ,CAAC,GAAW;YAC3B,MAAM,EAAE,GAAG,UAAU,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC;YAEnC,KAAK,GAAG,GAAG,CAAC;YAEZ,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE;gBAC3B,MAAM,MAAM,GAAG,EAAE,CAAC,GAAG,EAAE,SAAS,IAAI;oBAClC,IAAI,GAAG,GAAG,KAAK,EAAE;wBACf,MAAM,IAAI,SAAS,CAAC,gCAAgC,CAAC,CAAC;qBACvD;oBAED,IAAI,GAAG,GAAG,UAAU,CAAC,MAAM,EAAE;wBAC3B,MAAM,IAAI,SAAS,CACjB,wDAAwD,CACzD,CAAC;qBACH;oBAED,OAAO,QAAQ,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;gBAC3B,CAAC,CAAC,CAAC;gBAEH,IAAK,MAAc,KAAK,SAAS,EAAE;oBACjC,sBAAsB;oBACtB,MAAM,IAAI,SAAS,CACjB,mDAAmD,CACpD,CAAC;iBACH;gBAED,OAAO,OAAO,CAAC,MAAM,CAAC,CAAC;YACzB,CAAC,CAAC,CAAC;QACL,CAAC;QAED,OAAO,QAAQ,CAAC,KAAK,CAAC,CAAC;IACzB,CAAC,CAAC;AACJ,CAAC;AAED;;GAEG;AACH,SAAS,iBAAiB,CACxB,UAAmC;IAEnC,SAAS,QAAQ,CAAC,GAAW,EAAE,GAAM,EAAE,IAAgB;QACrD,MAAM,EAAE,GAAG,UAAU,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC;QAEnC,OAAO,IAAI,OAAO,CAAI,OAAO,CAAC,EAAE;YAC9B,OAAO,OAAO,CACZ,EAAE,CAAC,GAAG,EAAE,SAAS,IAAI;gBACnB,OAAO,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;YACtC,CAAC,CAAC,CACH,CAAC;QACJ,CAAC,CAAC,CAAC;IACL,CAAC;IAED,OAAO,SAAS,QAAQ,CAAC,GAAG,EAAE,IAAI;QAChC,OAAO,QAAQ,CAAC,CAAC,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;IAChC,CAAC,CAAC;AACJ,CAAC;AAED;;GAEG;AACU,QAAA,OAAO,GAClB,OAAO,CAAC,GAAG,CAAC,QAAQ,KAAK,YAAY,CAAC,CAAC,CAAC,iBAAiB,CAAC,CAAC,CAAC,eAAe,CAAC","sourcesContent":["/**\n * Next function supports optional `ctx` replacement for following middleware.\n */\nexport type Next<T> = () => Promise<T>;\n\n/**\n * Middleware function pattern.\n */\nexport type Middleware<T, U> = (ctx: T, next: Next<U>) => U | Promise<U>;\n\n/**\n * Final function has no `next()`.\n */\nexport type Done<T, U> = (ctx: T) => U | Promise<U>;\n\n/**\n * Composed function signature.\n */\nexport type Composed<T, U> = (ctx: T, done: Done<T, U>) => Promise<U>;\n\n/**\n * Debug mode wrapper for middleware functions.\n */\nfunction debugMiddleware<T, U>(\n  middleware: Array<Middleware<T, U>>\n): Composed<T, U> {\n  if (!Array.isArray(middleware)) {\n    throw new TypeError(\n      `Expected middleware to be an array, got ${typeof middleware}`\n    );\n  }\n\n  for (const fn of middleware) {\n    if ((typeof fn as any) !== \"function\") {\n      // tslint:disable-line\n      throw new TypeError(\n        `Expected middleware to contain functions, but got ${typeof fn}`\n      );\n    }\n  }\n\n  return function composedDebug(ctx: T, done: Done<T, U>) {\n    if ((typeof done as any) !== \"function\") {\n      // tslint:disable-line\n      throw new TypeError(\n        `Expected the last argument to be \\`done(ctx)\\`, but got ${typeof done}`\n      );\n    }\n\n    let index = 0;\n\n    function dispatch(pos: number): Promise<U> {\n      const fn = middleware[pos] || done;\n\n      index = pos;\n\n      return new Promise(resolve => {\n        const result = fn(ctx, function next() {\n          if (pos < index) {\n            throw new TypeError(\"`next()` called multiple times\");\n          }\n\n          if (pos > middleware.length) {\n            throw new TypeError(\n              \"Composed `done(ctx)` function should not call `next()`\"\n            );\n          }\n\n          return dispatch(pos + 1);\n        });\n\n        if ((result as any) === undefined) {\n          // tslint:disable-line\n          throw new TypeError(\n            \"Expected middleware to return `next()` or a value\"\n          );\n        }\n\n        return resolve(result);\n      });\n    }\n\n    return dispatch(index);\n  };\n}\n\n/**\n * Production-mode middleware composition (no errors thrown).\n */\nfunction composeMiddleware<T, U>(\n  middleware: Array<Middleware<T, U>>\n): Composed<T, U> {\n  function dispatch(pos: number, ctx: T, done: Done<T, U>): Promise<U> {\n    const fn = middleware[pos] || done;\n\n    return new Promise<U>(resolve => {\n      return resolve(\n        fn(ctx, function next() {\n          return dispatch(pos + 1, ctx, done);\n        })\n      );\n    });\n  }\n\n  return function composed(ctx, done) {\n    return dispatch(0, ctx, done);\n  };\n}\n\n/**\n * Compose an array of middleware functions into a single function.\n */\nexport const compose =\n  process.env.NODE_ENV === \"production\" ? composeMiddleware : debugMiddleware;\n"]}