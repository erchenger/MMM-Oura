{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;AAAA,+BAA2D;AAG3D;;GAEG;AACH,MAAa,aAAc,SAAQ,KAAK;IAGtC,YAAmB,QAAkB,EAAE,OAAe;QACpD,KAAK,CAAC,OAAO,CAAC,CAAC;QADE,aAAQ,GAAR,QAAQ,CAAU;QAFrC,SAAI,GAAG,kBAAkB,CAAC;IAI1B,CAAC;CACF;AAND,sCAMC;AAED;;GAEG;AACH,SAAgB,eAAe;IAC7B,OAAO,KAAK,WAAU,GAAM,EAAE,IAAsB;QAClD,IAAI,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,iBAAiB,CAAC;YAAE,OAAO,IAAI,EAAE,CAAC;QAEtD,GAAG,CAAC,OAAO,CAAC,GAAG,CACb,iBAAiB,EACjB,6BAAsB,CAAC,CAAC,CAAC,mBAAmB,CAAC,CAAC,CAAC,eAAe,CAC/D,CAAC;QAEF,MAAM,GAAG,GAAG,MAAM,IAAI,EAAE,CAAC;QACzB,MAAM,GAAG,GAAG,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,kBAAkB,CAAC,CAAC;QAEhD,qDAAqD;QACrD,IAAI,GAAG,KAAK,SAAS,IAAI,GAAG,KAAK,MAAM,EAAE;YACvC,GAAG,CAAC,QAAQ,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,kBAAW,EAAE,CAAC,CAAC;SACjD;aAAM,IAAI,GAAG,KAAK,IAAI,EAAE;YACvB,IAAI,6BAAsB,EAAE;gBAC1B,GAAG,CAAC,QAAQ,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,6BAAsB,EAAE,CAAC,CAAC;aAC5D;iBAAM;gBACL,MAAM,IAAI,aAAa,CAAC,GAAG,EAAE,mCAAmC,CAAC,CAAC;aACnE;SACF;aAAM,IAAI,GAAG,IAAI,GAAG,KAAK,UAAU,EAAE;YACpC,MAAM,IAAI,aAAa,CAAC,GAAG,EAAE,qBAAqB,GAAG,YAAY,CAAC,CAAC;SACpE;QAED,OAAO,GAAG,CAAC;IACb,CAAC,CAAC;AACJ,CAAC;AA3BD,0CA2BC","sourcesContent":["import { createUnzip, createBrotliDecompress } from \"zlib\";\nimport { Request, Response } from \"servie/dist/node\";\n\n/**\n * Decoding errors.\n */\nexport class EncodingError extends Error {\n  code = \"EINVALIDENCODING\";\n\n  constructor(public response: Response, message: string) {\n    super(message);\n  }\n}\n\n/**\n * Automatically support decoding compressed HTTP responses.\n */\nexport function contentEncoding<T extends Request, U extends Response>() {\n  return async function(req: T, next: () => Promise<U>): Promise<U> {\n    if (req.headers.has(\"Accept-Encoding\")) return next();\n\n    req.headers.set(\n      \"Accept-Encoding\",\n      createBrotliDecompress ? \"gzip, deflate, br\" : \"gzip, deflate\"\n    );\n\n    const res = await next();\n    const enc = res.headers.get(\"Content-Encoding\");\n\n    // Unzip body automatically when response is encoded.\n    if (enc === \"deflate\" || enc === \"gzip\") {\n      res.$rawBody = res.stream().pipe(createUnzip());\n    } else if (enc === \"br\") {\n      if (createBrotliDecompress) {\n        res.$rawBody = res.stream().pipe(createBrotliDecompress());\n      } else {\n        throw new EncodingError(res, \"Unable to support Brotli decoding\");\n      }\n    } else if (enc && enc !== \"identity\") {\n      throw new EncodingError(res, `Unable to decode \"${enc}\" encoding`);\n    }\n\n    return res;\n  };\n}\n"]}