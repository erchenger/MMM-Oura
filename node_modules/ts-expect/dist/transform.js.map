{"version":3,"file":"transform.js","sourceRoot":"","sources":["../src/transform.ts"],"names":[],"mappings":";;AAAA,iCAAiC;AAEjC;;GAEG;AACH;IACE,SAAS,OAAO,CACd,OAAiC,EACjC,UAAyB;QAEzB,IAAI,QAAQ,GAAG,IAAI,GAAG,EAAE,CAAC;QAEzB,OAAO,SAAS,KAAK,CAAC,IAAa;YACjC,IAAI,EAAE,CAAC,mBAAmB,CAAC,IAAI,CAAC,EAAE;gBAChC,MAAM,UAAU,GAAG,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;gBAE/D,IAAI,UAAU,KAAK,WAAW,IAAI,IAAI,CAAC,YAAY,EAAE;oBACnD,MAAM,EAAE,aAAa,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC;oBAE5C,IAAI,aAAa,EAAE;wBACjB,EAAE,CAAC,YAAY,CAAC,aAAa,EAAE,CAAC,CAAC,EAAE,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;qBAChE;oBAED,OAAO,IAAI,CAAC,CAAC,4BAA4B;iBAC1C;aACF;YAED,IAAI,EAAE,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE;gBAC3B,MAAM,WAAW,GAAG,IAAI,GAAG,CAAC,QAAQ,CAAC,CAAA;gBAErC,4BAA4B;gBAC5B,IAAI,CAAC,UAAU;qBACZ,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;qBAC1B,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;qBAC5B,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;gBAEpC,MAAM,MAAM,GAAG,EAAE,CAAC,cAAc,CAAC,IAAI,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;gBACvD,QAAQ,GAAG,WAAW,CAAC,CAAC,oBAAoB;gBAC5C,OAAO,MAAM,CAAC;aACf;YAED,IAAI,EAAE,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE;gBAC7B,IAAI,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,CAAC,EAAE;oBAC3C,OAAO,EAAE,CAAC,cAAc,EAAE,CAAC;iBAC5B;gBAED,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,CAAC;gBAC9C,IAAI,KAAK,IAAI,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC,EAAE;oBAC1C,OAAO,EAAE,CAAC,cAAc,EAAE,CAAC;iBAC5B;gBAED,OAAO,IAAI,CAAC;aACb;YAED,OAAO,EAAE,CAAC,cAAc,CAAC,IAAI,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;QACjD,CAAC,CAAC;IACJ,CAAC;IAED,OAAO,SAAS,WAAW,CAAC,OAAiC;QAC3D,OAAO,CAAC,UAAyB,EAAE,EAAE,CACnC,EAAE,CAAC,SAAS,CAAC,UAAU,EAAE,OAAO,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC,CAAC;IAC3D,CAAC,CAAC;AACJ,CAAC;AAzDD,4BAyDC","sourcesContent":["import * as ts from \"typescript\";\n\n/**\n * Strip TypeScript expectations from runtime code.\n */\nexport default function(): ts.TransformerFactory<ts.SourceFile> {\n  function visitor(\n    context: ts.TransformationContext,\n    sourceFile: ts.SourceFile\n  ): ts.Visitor {\n    let keywords = new Set();\n\n    return function visit(node: ts.Node): ts.VisitResult<ts.Node> {\n      if (ts.isImportDeclaration(node)) {\n        const importName = node.moduleSpecifier.getText().slice(1, -1);\n\n        if (importName === \"ts-expect\" && node.importClause) {\n          const { namedBindings } = node.importClause;\n\n          if (namedBindings) {\n            ts.forEachChild(namedBindings, x => keywords.add(x.getText()));\n          }\n\n          return node; // Let minifier handle this.\n        }\n      }\n\n      if (ts.isFunctionLike(node)) {\n        const oldKeywords = new Set(keywords)\n\n        // Remove shadowed keywords.\n        node.parameters\n          .map(x => x.name.getText())\n          .filter(x => keywords.has(x))\n          .forEach(x => keywords.delete(x));\n\n        const result = ts.visitEachChild(node, visit, context);\n        keywords = oldKeywords; // Restore keywords.\n        return result;\n      }\n\n      if (ts.isCallExpression(node)) {\n        if (keywords.has(node.expression.getText())) {\n          return ts.createVoidZero();\n        }\n\n        const token = node.expression.getFirstToken();\n        if (token && keywords.has(token.getText())) {\n          return ts.createVoidZero();\n        }\n\n        return node;\n      }\n\n      return ts.visitEachChild(node, visit, context);\n    };\n  }\n\n  return function transformer(context: ts.TransformationContext) {\n    return (sourceFile: ts.SourceFile) =>\n      ts.visitNode(sourceFile, visitor(context, sourceFile));\n  };\n}\n"]}