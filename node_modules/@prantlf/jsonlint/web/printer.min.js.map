{"version":3,"sources":["lib/printer.js"],"names":["global","factory","exports","module","define","amd","self","jsonlintPrinter","this","noop","isIdentifierName","value","test","concatenateTokens","tokens","outputString","tokenCount","length","tokenIndex","raw","print","options","Error","indentString","indent","Array","join","prettyPrint","undefined","pruneComments","stripObjectKeys","enforceDoubleQuotes","enforceSingleQuotes","trimTrailingCommas","foundLineBreak","addedLineBreak","needsLineBreak","addedSpace","needsSpace","indentLevel","scopes","scopeType","isValue","token","tokenType","tokenContent","peekAtNextToken","nextTokenIndex","nextToken","type","addIndent","i","addLineBreak","addDelayedSpaceOrLineBreak","addStandaloneComment","tryAddingInlineComment","tryTokenIndex","skipWhitespace","indexOf","substr","addLiteral","tokenValue","JSON","stringify","replace","openScope","push","closeScope","pop","addComma","addColon","Object","defineProperty"],"mappings":"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","file":"printer.js","sourcesContent":["(function (global, factory) {\n  // eslint-disable-next-line no-unused-expressions\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports)\n  // eslint-disable-next-line no-undef\n    : typeof define === 'function' && define.amd ? define('jsonlint-printer', ['exports'], factory)\n    // eslint-disable-next-line no-undef\n      : (global = global || self, factory(global.jsonlintPrinter = {}))\n}(this, function (exports) {\n  'use strict'\n\n  function noop () {}\n\n  function isIdentifierName (value) {\n    return /^[a-zA-Z$_][a-zA-Z0-9$_]*$/.test(value)\n  }\n\n  function concatenateTokens (tokens) {\n    var outputString = ''\n    var tokenCount = tokens.length\n    var tokenIndex\n    for (tokenIndex = 0; tokenIndex < tokenCount; ++tokenIndex) {\n      outputString += tokens[tokenIndex].raw\n    }\n    return outputString\n  }\n\n  function print (tokens, options) {\n    if (!(tokens && tokens.length)) {\n      throw new Error('JSON tokens missing.')\n    }\n    // Whitespace and comments are available only as raw token content.\n    if (!(tokens[0] && tokens[0].raw)) {\n      throw new Error('JSON tokens lack raw values.')\n    }\n\n    if (!options) {\n      // If no options, not even an empty object is passed, just concatenate\n      // the raw tokens with neither minification, nor pretty-printing.\n      return concatenateTokens(tokens)\n    }\n\n    var indentString = options.indent\n    if (typeof indentString === 'number') {\n      indentString = new Array(indentString + 1).join(' ')\n    }\n    // Setting the indent to an empty string enables pretty-printing too.\n    // It will just insert line breaks without any indentation.\n    var prettyPrint = indentString !== undefined\n    var pruneComments = options.pruneComments\n    var stripObjectKeys = options.stripObjectKeys\n    var enforceDoubleQuotes = options.enforceDoubleQuotes\n    var enforceSingleQuotes = options.enforceSingleQuotes\n    var trimTrailingCommas = options.trimTrailingCommas\n\n    var outputString = ''\n    var foundLineBreak, addedLineBreak, needsLineBreak\n    var addedSpace, needsSpace\n    var indentLevel = 0\n    var scopes = []\n    var scopeType\n    var isValue\n    var tokenCount = tokens.length\n    var tokenIndex, token, tokenType, tokenContent\n\n    function peekAtNextToken () {\n      var nextTokenIndex = tokenIndex\n      var nextToken\n      do {\n        nextToken = tokens[++nextTokenIndex]\n      } while (nextToken && (nextToken.type === 'whitespace' ||\n                             nextToken.type === 'comment'))\n      return nextToken\n    }\n\n    var addIndent\n    if (prettyPrint && indentString) {\n      addIndent = function () {\n        for (var i = 0; i < indentLevel; ++i) {\n          outputString += indentString\n        }\n      }\n    } else {\n      addIndent = noop\n    }\n\n    var addLineBreak, addDelayedSpaceOrLineBreak\n    if (prettyPrint) {\n      addLineBreak = function () {\n        outputString += '\\n'\n      }\n\n      addDelayedSpaceOrLineBreak = function () {\n        // A line break is more important than a space.\n        if (needsLineBreak) {\n          addLineBreak()\n          addIndent()\n        } else if (needsSpace) {\n          outputString += ' '\n        }\n        needsSpace = needsLineBreak = false\n      }\n    } else {\n      addLineBreak = addDelayedSpaceOrLineBreak = noop\n    }\n\n    var addStandaloneComment, tryAddingInlineComment\n    if (pruneComments) {\n      addStandaloneComment = tryAddingInlineComment = noop\n    } else {\n      if (prettyPrint) {\n        addStandaloneComment = function () {\n          // If a comment is not appended to the end of a line, it will start\n          // on a new line with the current indentation.\n          if (!addedLineBreak && tokenIndex > 0) {\n            addLineBreak()\n            addIndent()\n          }\n          outputString += tokenContent\n          foundLineBreak = false\n          addedLineBreak = false\n          // If a comment is not appended to the end of a line, it will take\n          // the whole line and has to end by a line break.\n          needsLineBreak = true\n        }\n\n        tryAddingInlineComment = function () {\n          // This function is called after printing a non-line-break character.\n          foundLineBreak = false\n          addedLineBreak = false\n          addedSpace = false\n\n          // Start with the character after the just processed one.\n          var tryTokenIndex = tokenIndex + 1\n\n          function skipWhitespace () {\n            var token = tokens[tryTokenIndex]\n            if (token && token.type === 'whitespace') {\n              foundLineBreak = token.raw.indexOf('\\n') >= 0\n              token = tokens[++tryTokenIndex]\n            }\n            return token\n          }\n\n          var token = skipWhitespace()\n          // If line break followed the previous token, leave the comment\n          // to be handled by the next usual token processing.\n          if (!foundLineBreak && token && token.type === 'comment') {\n            if (needsLineBreak) {\n              // If the previous non-whitespace token was ended by a line\n              // break, retain it. Print the comment after the line break too.\n              if (!addedLineBreak) {\n                addLineBreak()\n                addIndent()\n              }\n            } else {\n              // If the previous non-whitespace token was not ended by a line\n              // break, ensure that the comment is separated from it.\n              if (!addedSpace) {\n                outputString += ' '\n              }\n            }\n            outputString += token.raw\n            // Set the current token to the just processed comment.\n            tokenIndex = tryTokenIndex++\n            // Check the whitespace after the comment to give a hint\n            // about the next whitespace to the further processing.\n            skipWhitespace()\n            if (foundLineBreak) {\n              needsSpace = false\n              needsLineBreak = true\n            } else {\n              needsSpace = true\n              needsLineBreak = false\n            }\n          }\n        }\n      } else {\n        // If all whitespace is omitted, convert single-line comments\n        // to multi-line ones, which include a comment-closing token.\n        addStandaloneComment = function () {\n          if (tokenContent[1] === '/') {\n            outputString += '/*'\n            outputString += tokenContent.substr(2, tokenContent.length - 2)\n            outputString += ' */'\n          } else {\n            outputString += tokenContent\n          }\n        }\n\n        tryAddingInlineComment = noop\n      }\n    }\n\n    function addLiteral () {\n      addDelayedSpaceOrLineBreak()\n      var tokenValue = token.value\n      if (stripObjectKeys && scopeType === '{' && !isValue &&\n          isIdentifierName(tokenValue)) {\n        outputString += tokenValue\n      } else if (typeof tokenValue === 'string') {\n        if (enforceDoubleQuotes && tokenContent[0] !== '\"') {\n          outputString += JSON.stringify(tokenValue)\n        } else if (enforceSingleQuotes && tokenContent[0] !== '\\'') {\n          outputString += '\\'' + tokenValue.replace(/'/g, '\\\\\\'') + '\\''\n        } else {\n          outputString += tokenContent\n        }\n      } else {\n        outputString += tokenContent\n      }\n      tryAddingInlineComment()\n    }\n\n    function openScope () {\n      addDelayedSpaceOrLineBreak()\n      scopes.push(scopeType)\n      scopeType = tokenContent\n      isValue = scopeType === '['\n      outputString += tokenContent\n      tryAddingInlineComment()\n      ++indentLevel\n      needsLineBreak = true\n    }\n\n    function closeScope () {\n      scopeType = scopes.pop()\n      addLineBreak()\n      --indentLevel\n      addIndent()\n      needsSpace = needsLineBreak = false\n      outputString += tokenContent\n      tryAddingInlineComment()\n    }\n\n    function addComma () {\n      if (trimTrailingCommas) {\n        var nextToken = peekAtNextToken()\n        if (nextToken && nextToken.type === 'symbol') {\n          return tryAddingInlineComment()\n        }\n      }\n      addDelayedSpaceOrLineBreak()\n      outputString += ','\n      tryAddingInlineComment()\n      addLineBreak()\n      addIndent()\n      addedLineBreak = true\n      needsLineBreak = false\n      isValue = scopeType === '['\n    }\n\n    function addColon () {\n      addDelayedSpaceOrLineBreak()\n      outputString += ':'\n      needsSpace = true\n      tryAddingInlineComment()\n      isValue = true\n    }\n\n    for (tokenIndex = 0; tokenIndex < tokenCount; ++tokenIndex) {\n      token = tokens[tokenIndex]\n      tokenType = token.type\n      tokenContent = token.raw\n      switch (tokenType) {\n        case 'literal':\n          addLiteral()\n          break\n        case 'comment':\n          addStandaloneComment()\n          break\n        case 'symbol':\n          switch (tokenContent) {\n            case '{':\n            case '[':\n              openScope()\n              break\n            case '}':\n            case ']':\n              closeScope()\n              break\n            case ',':\n              addComma()\n              break\n            case ':':\n              addColon()\n          }\n          break\n        default: // whitespace\n          foundLineBreak = tokenContent.indexOf('\\n') >= 0\n      }\n    }\n\n    return outputString\n  }\n\n  exports.print = print\n\n  Object.defineProperty(exports, '__esModule', { value: true })\n}))\n"]}